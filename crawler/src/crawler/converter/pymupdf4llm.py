"""
PyMuPDF4LLM converter: convert PDFs to Markdown using pymupdf4llm, then
replace embedded images with VLM-generated descriptions.

- Uses pymupdf4llm.to_markdown(embed_images=True) to get Markdown containing
  base64 data-URI images.
- Finds those images and replaces each with a textual description generated by
  a Vision-Language Model (VLM).
- Supports Ollama (llava, etc.) or a Dummy VLM fallback.

Requirements:
- pymupdf (fitz)
- pymupdf4llm
- requests (only if using OllamaVLM)
"""

from __future__ import annotations

import base64
import hashlib
import re
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Any, Literal

import fitz  # PyMuPDF
from pydantic import BaseModel, Field

from ..llm.llm import LLMConfig
from .base import Converter
from .types import ConversionStats, ConvertedDocument, DocumentInput

# ----------------------------- VLM Interfaces ---------------------------------


class VLMInterface:
    """Abstract interface for image description services."""

    def describe_image(self, image_data: bytes, image_ext: str, prompt: str | None = None) -> str:
        raise NotImplementedError


class OllamaVLM(VLMInterface):
    """Implementation for Ollama API VLM."""

    def __init__(
        self,
        model_name: str = "llava",
        base_url: str = "http://localhost:11434",
        timeout_sec: int = 60,
    ):
        if not isinstance(model_name, str) or not model_name.strip():
            raise ValueError("OllamaVLM requires a non-empty model_name")
        if not isinstance(base_url, str) or not base_url.strip():
            raise ValueError("OllamaVLM requires a non-empty base_url")

        self.model_name = model_name
        self.base_url = base_url.rstrip("/")
        self.timeout_sec = timeout_sec

        try:
            import requests  # type: ignore

            self.requests = requests
        except ImportError as e:
            raise ImportError("requests library not found. Install with: pip install requests") from e

    def describe_image(self, image_data: bytes, image_ext: str, prompt: str | None = None) -> str:
        try:
            image_b64 = base64.b64encode(image_data).decode("utf-8")
            prompt = prompt or "Describe this image in detail. Focus on the main content, " "objects, text, and any relevant information useful in a " "document context."

            url = f"{self.base_url}/api/generate"
            payload = {
                "model": self.model_name,
                "prompt": prompt,
                "images": [image_b64],
                "stream": False,
            }
            headers = {"Content-Type": "application/json"}

            resp = self.requests.post(url, json=payload, headers=headers, timeout=self.timeout_sec)
            if resp.status_code == 200:
                data = resp.json()
                desc = (data.get("response") or "").strip()
                return desc or f"[No description returned for {image_ext} image]"
            return f"[Ollama error: HTTP {resp.status_code}]"
        except Exception as e:
            return f"[Error describing image: {e}]"


class DummyVLM(VLMInterface):
    """Dummy implementation for testing and as a safe fallback."""

    def describe_image(self, image_data: bytes, image_ext: str, prompt: str | None = None) -> str:
        return f"[Image ({image_ext}), {len(image_data)} bytes]"


# --------------------------------- Config -------------------------------------


class PyMuPDF4LLMConfig(BaseModel):
    """Configuration for PyMuPDF4LLM converter."""

    type: Literal["pymupdf4llm"] = "pymupdf4llm"

    # VLM settings
    vlm_config: LLMConfig | None = Field(default=None, description="VLM configuration")
    image_prompt: str | None = Field(
        default=("Describe this image in detail. Focus on the main content, objects, " "text, and any relevant information useful in a document context."),
        description="Prompt used when describing images",
    )
    max_workers: int = Field(default=4, ge=1, le=32, description="Max concurrent image descriptions")

    # to_markdown controls (keep simple; always embed_images=True for this flow)
    to_markdown_kwargs: dict[str, Any] = Field(
        default_factory=dict,
        description=(
            "Extra kwargs forwarded to pymupdf4llm.to_markdown(). " "embed_images will be forced to True; page_chunks will be forced " "to False so that a single markdown string is returned."
        ),
    )


# ------------------------------- Utilities ------------------------------------


def fix_paragraph_newlines(md_text: str) -> str:
    """
    Merge single newlines within paragraphs in a Markdown document,
    but preserve double newlines and section formatting.
    """
    # Normalize line endings
    text = md_text.replace("\r\n", "\n")

    # Replace single newlines (between non-empty lines) with spaces
    fixed = re.sub(r"(?<!\n)\n(?!\n)", " ", text)

    # Optionally: remove spaces before punctuation (caused by joining)
    fixed = re.sub(r" +([.,;:!?])", r"\1", fixed)

    return fixed


_DATA_URI_IMG_RE = re.compile(
    r"!\[(?P<alt>[^\]]*)\]\(" r"(?P<uri>data:image/(?P<subtype>[a-zA-Z0-9.+-]+);base64," r"(?P<b64>[A-Za-z0-9+/=\s]+))\)",
    re.IGNORECASE | re.DOTALL,
)


def _hash_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()


def _ext_from_subtype(subtype: str) -> str:
    st = (subtype or "").lower()
    if st in ("jpeg", "jpg", "pjpeg"):
        return "jpg"
    if st in ("svg+xml", "svg"):
        return "svg"
    if st in ("tiff", "tif"):
        return "tiff"
    return st or "png"


def _open_as_pymupdf_document(doc: DocumentInput) -> fitz.Document:
    """
    Return a fitz.Document for the given DocumentInput.
    Uses file path if available, else opens from bytes.
    """
    if getattr(doc, "source", None) == "path" and getattr(doc, "path", None):
        return fitz.open(str(doc.path))
    # else read bytes from fileobj or bytes_data
    if getattr(doc, "bytes_data", None):
        return fitz.open(stream=doc.bytes_data, filetype="pdf")
    if getattr(doc, "fileobj", None):
        data = doc.fileobj.read()
        return fitz.open(stream=data, filetype="pdf")
    raise ValueError("Unsupported DocumentInput: no path, bytes_data, or fileobj")


def _describe_images_concurrently(
    vlm: VLMInterface,
    items: list[tuple[str, str, bytes]],
    prompt: str | None,
    max_workers: int,
) -> dict[str, str]:
    """
    Describe a list of images concurrently.
    items: list of (key, ext, bytes) where key is a unique identifier (hash).
    Returns dict key -> description.
    """
    results: dict[str, str] = {}
    if not items:
        return results

    # Deduplicate by content hash key
    unique: dict[str, tuple[str, bytes]] = {}
    for key, ext, data in items:
        if key not in unique:
            unique[key] = (ext, data)

    def task(k: str, e: str, d: bytes) -> tuple[str, str]:
        desc = vlm.describe_image(d, e, prompt)
        return k, desc

    with ThreadPoolExecutor(max_workers=max_workers) as ex:
        futs = [ex.submit(task, k, e, d) for k, (e, d) in unique.items()]
        for f in as_completed(futs):
            k, desc = f.result()
            results[k] = desc
    return results


def _replace_images_with_descriptions(markdown: str, desc_map: dict[str, str]) -> str:
    """
    Replace markdown data-URI image tags with text descriptions.
    The mapping is keyed by the sha256 hash of the decoded image bytes.
    """

    def repl(m: re.Match) -> str:
        b64 = m.group("b64")
        try:
            data = base64.b64decode(b64, validate=False)
        except Exception:
            # If decode fails, keep original tag
            return m.group(0)
        key = _hash_bytes(data)
        desc = desc_map.get(key)
        if not desc:
            # if missing (shouldn't happen), keep original tag
            return m.group(0)
        # Replace the whole image markdown with a simple emphasized description.
        # You can customize this to include the original alt text if desired.
        return f"*{desc}*"

    return _DATA_URI_IMG_RE.sub(repl, markdown)


# -------------------------------- Converter -----------------------------------


class PyMuPDF4LLMConverter(Converter):
    """Converter using pymupdf4llm and a VLM to replace images with descriptions."""

    def __init__(self, config: PyMuPDF4LLMConfig):
        super().__init__(config)
        self.config = config
        self.vlm = self._create_vlm()

    @property
    def name(self) -> str:
        return "PyMuPDF4LLM"

    def convert(self, doc: DocumentInput) -> ConvertedDocument:
        import pymupdf4llm  # imported here to make dependency explicit

        start_time = time.time()
        warnings: list[str] = []

        # 1) Open as PyMuPDF Document
        try:
            pdf_doc = _open_as_pymupdf_document(doc)
        except Exception as e:
            raise RuntimeError(f"Failed to open document: {e}")

        try:
            # 2) Prepare to_markdown kwargs
            kwargs = dict(self.config.to_markdown_kwargs or {})
            # Force a single markdown string and embedded images
            kwargs["embed_images"] = True
            kwargs["page_chunks"] = False

            # Optional: propagate filename for nicer metadata in pymupdf4llm
            if getattr(doc, "filename", None) and "filename" not in kwargs:
                kwargs["filename"] = str(doc.filename)

            # 3) Generate markdown
            md_text = pymupdf4llm.to_markdown(pdf_doc, **kwargs)
            if not isinstance(md_text, str):
                # Safety: if page_chunks somehow enabled, join texts
                try:
                    md_text = "\n\n".join((p.get("text", "") or "") for p in (md_text or []))
                except Exception:
                    md_text = ""

            md_text = fix_paragraph_newlines(md_text)

            # 4) Collect images from markdown for VLM description
            to_describe: list[tuple[str, str, bytes]] = []
            for m in _DATA_URI_IMG_RE.finditer(md_text):
                subtype = m.group("subtype") or "png"
                b64 = m.group("b64")
                try:
                    data = base64.b64decode(b64, validate=False)
                    key = _hash_bytes(data)
                    ext = _ext_from_subtype(subtype)
                    to_describe.append((key, ext, data))
                except Exception:
                    continue

            # 5) Describe images (concurrently, with dedup)
            desc_map: dict[str, str] = {}
            if to_describe:
                try:
                    desc_map = _describe_images_concurrently(
                        self.vlm,
                        to_describe,
                        self.config.image_prompt,
                        max_workers=self.config.max_workers,
                    )
                except Exception as e:
                    warnings.append(f"Image description failed: {e}")

            # 6) Replace images with descriptions
            if desc_map:
                md_text = _replace_images_with_descriptions(md_text, desc_map)

            total_time = time.time() - start_time

            # 7) Return ConvertedDocument (minimal fields required)
            # If your ConvertedDocument supports more fields (metadata, stats),
            # extend here as needed.
            return ConvertedDocument(
                markdown=md_text,
                metadata=getattr(pdf_doc, "metadata", {}) or {},
                warnings=warnings,
                stats=ConversionStats(
                    total_pages=len(pdf_doc),
                    processed_pages=len(pdf_doc),
                    total_time_sec=total_time,
                    images_described=len(desc_map),
                ),
            )
        finally:
            try:
                pdf_doc.close()
            except Exception:
                pass

    # -------------------------- Internal helpers ------------------------------

    def _create_vlm(self) -> VLMInterface:
        """Create and configure the VLM based on configuration."""
        cfg = self.config.vlm_config
        if cfg is None:
            return DummyVLM()

        provider = getattr(cfg, "provider", None)
        if provider == "ollama":
            model_name = getattr(cfg, "model_name", "llava")
            base_url = getattr(cfg, "base_url", "http://localhost:11434")
            timeout_sec = getattr(cfg, "timeout_sec", 60)
            try:
                return OllamaVLM(
                    model_name=model_name,
                    base_url=base_url,
                    timeout_sec=timeout_sec,
                )
            except Exception:
                return DummyVLM()

        if provider == "dummy":
            return DummyVLM()

        # Unknown provider -> safe fallback
        return DummyVLM()
